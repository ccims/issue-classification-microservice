[{"labels":["documentation",null,null],"text":"https://deno.land/std/async and https://deno.land/std/signal are missing readme's - i assume it would be best to have one like the other modules to document the modules methods?"},{"labels":["documentation"],"text":"Make the point for deps.ts even clearer in documentation - PR follows in a few minutes.\r\n"},{"labels":["documentation",null,null],"text":"there are many exported functions in standard library but some functions' JSDocs are missing\r\n\r\nhere is the list of ts files that need to be updated\r\n\r\n- [ ] `encoding/hex.ts`\r\n- [ ] `encoding/toml.ts`\r\n- [ ] `fmt/colors.ts`\r\n- [ ] `fmt/printf.ts`\r\n- [ ] `fs/walk.ts`\r\n- [ ] `http/file_server.ts`\r\n- [ ] `io/streams.ts`\r\n- [ ] `io/util.ts`\r\n- [ ] `log/mod.ts`\r\n- [ ] `node/querystring`\r\n- [ ] `node/url.ts`\r\n- [ ] `node/util.ts`\r\n- [ ] `path.posix.ts`\r\n- [ ] `path/win32.ts`\r\n- [ ] `testing/assert.ts`\r\n- [ ] `testing/diff.ts`\r\n- [ ] `uuid/mod.ts`\r\n- [ ] `uuid/v1.ts`\r\n- [ ] `uuid/v4.ts`\r\n- [ ] `uuid/v5.ts`\r\n- [ ] `ws/mod.ts`\r\n"},{"labels":[null,"documentation"],"text":"Should demonstrate how to use ops (sync json would be easiest to grok)"},{"labels":["documentation"],"text":"I simply cannot find ANY documentation on the following extremely useful imports:\r\n\r\n```\r\nimport { BufReader, BufWriter } from 'https://deno.land/std@0.67.0/io/bufio.ts';\r\nimport { TextProtoReader }      from 'https://deno.land/std@0.67.0/textproto/mod.ts';\r\n```\r\n\r\nCan these please be documented. I'm a huge fan of Deno but right now I am literally copying & pasting code knowing that's going to break and hours later it eventually works but I have no idea how. It's like coding in the dark."},{"labels":["documentation",null],"text":"Seems documentation on std/fmt/colors.ts is missing/absent from std/fmt's README.md\r\n\r\nIt'd be nice to see the readme updated with 'API docs' for the colors script/module"},{"labels":["documentation"],"text":"WebAssembly\r\n  - [ ] Link to MDN sources\r\n  - [ ] Provide Rust program that compiles to provided bytes\r\n  - [ ] Write about instantiateStreaming currently not supported\r\n\r\nTypeScript\r\n  - [ ] Make a separate chapter\r\n\r\nIO model\r\n  - [ ] How IO work in Deno\r\n  - [ ] comparison with ReadableStream, WriteableStream\r\n  - [ ] how to convert to/from ReadableStream\r\n\r\n\r\nComparison with Node.js\r\n  - [ ] Make a separate chapter\r\n  - [ ] Compare most common Node APIs with Deno equivalents\r\n  - [ ] Write about popular Node packages that are built into Deno\r\n\r\nPlugins\r\n  - [ ] Link to example plugin\r\n  - [ ] Basic \"fetch.js\", deno_core::explanation\r\n\r\nExamples\r\n  - [x] Move higher in the menu order\r\n\r\nTools\r\n  - [x] Move “Debugger” to “Debugging your code” in “Getting started”\r\n  - [ ] Bundler - point out “for await of” does not work, it is an upstream bug, provide a workaround (ie. async iffe)\r\n\r\nDeploying your code\r\n  - [ ] Bundle it\r\n  - [ ] How to setup basic CI\r\n  - [ ] Best practices\r\n\r\nArchitecture\r\n  - [ ] Draw new diagram\r\n  - [x] Link to @ry’s talk about deno structure from Israel meetup https://www.youtube.com/watch?v=1b7FoBwxc7E\r\n\r\nBuilding from source\r\n  - [ ] Update\r\n  - [ ] Style guide - ask @piscisaureus to update it\r\n\r\n- [x] Provide special markers for Deno version and corresponding std version and automatically insert in all examples - eg. `$DENO_VERSION$`/`$STD_VERSION$`\r\n\r\n- [ ] Links to API reference, std library should be visible on every page of the manual\r\n\r\nTesting\r\n- [ ] how tests are registered\r\n- [ ] processing order\r\n- [ ] concurrency\r\n\r\nStd:\r\n- [ ] All imports in readme examples should be versioned, and bumped on release"},{"labels":["documentation",null],"text":"Deno.Process probably needs a bit more documentation:\r\n\r\n- if `close()` is called, `status()` will throw an exception with a bad resource id.\r\n- `kill()` followed by a `status()` works fine\r\n- I would expect `status()` to always work regardless of how the process was terminated.\r\n\r\n\r\nI would have expected status() to resolve its promise regardless of how the Process is closed/kill or otherwise.\r\n\r\nMy use of Deno.run() is running a server that I can use for tests. So this creates interesting because if things don't close properly, the tests will fail with resource leaks (love that).\r\n\r\n\r\n"},{"labels":[null,"documentation"],"text":"The unstable doc shows `{certificate, hostname, port}` as a snippet in https://doc.deno.land/https/raw.githubusercontent.com/denoland/deno/master/cli/js/lib.deno.unstable.d.ts#Deno.startTls.\r\n\r\n[port is likely not needed for Deno.startTls]\r\n\r\nHowever, https://doc.deno.land/https/raw.githubusercontent.com/denoland/deno/master/cli/js/lib.deno.unstable.d.ts#Deno.StartTlsOptions only has `{certificate, hostname}`.\r\n\r\nAlso - for client certificate authentication, the client certificate, key, and a ca certificate will be required (for self-signed cert conditions).\r\n"},{"labels":["documentation"],"text":"https://deno.land/manual/tools"},{"labels":["documentation"],"text":"https://deno.land/manual/contributing/development_tools#profiling\r\n\r\nThe v8 tools don't seem to be pulled `cargo build -vv` or `V8_FROM_SOURCE=1 cargo build -vv`. Resorting to v8 documentation (and the google toolchain installation).\r\n\r\nWould be great, if instead deno itself embedded the tool to convert the capture profile logs (as nodejs does).\r\n"},{"labels":[null,"documentation"],"text":"![image](https://user-images.githubusercontent.com/28331609/83350132-874d3180-a36c-11ea-9726-19aea226453c.png)\r\n"},{"labels":["documentation"],"text":"Looks like IntelliJ got official Deno plugin: https://plugins.jetbrains.com/plugin/14382-deno \r\n\r\nManual entry about debugging should be updated: https://deno.land/manual/tools/debugger"},{"labels":[null,"documentation"],"text":"The diagram shows libdeno (C++). I could be wrong, but isn't this replaced with rusty_v8?\r\n\r\nhttps://deno.land/manual/contributing/architecture#schematic-diagram"},{"labels":["documentation",null],"text":"Docs for following APIs should be updated:\r\n- `Deno.read()`\r\n- `Deno.readSync()`\r\n- `Deno.write()`\r\n- `Deno.writeSync()`\r\n\r\nIt's not sufficiently explained that these function are the lowest level APIs and most users should not work with them directly. It is  **crucial to explain in bold** that it's not guaranteed that full buffer will be read/written in a single call. \r\n\r\nIn most cases it's `Deno.readAll()` or `Deno.writeAll()` that should be used."},{"labels":[null,"documentation"],"text":"Deno `Conn`s provide a `Reader`, `Writer`, and `Closer`. The first two are promise driven apis, the last one is not.\r\n\r\nThere are possibly many async operations (one trying to read, and many other async writes) in an active connection.\r\nWhen calling `close()` on the connection, it is possible that there are many pending writer ops, enough that any simple test reading/writing will fail with resource leakage (thanks for this).\r\n\r\nThis means that in order to close in a somewhat clean way, all API clients will have to set up a promise that resolves on a read failure (similar issue on `listen`) and track the individual promises returned by write into a stack and `shift()` them out as they resolve.\r\n\r\nThe setup to call `close()` typically means setting up a flag to ignore any read/write attempts from some other async operation trying to use the connection, and then waiting on the reader promise and all the write promises to resolve/fail. Only then can `close()` be called.\r\n\r\nSince the `Conn` should know about the state of the read and the number of pending writes scheduled, it seems reasonable to prevent much of this boilerplate by simply returning a promise from close(), which would signal at that point when the controlling process can safely exit or whatnot.\r\n\r\n"},{"labels":[null,"documentation"],"text":"I'm not hugely familiar with CLI standards, but I don't think I've ever run in to the requirement that --flags precede the positional arguments. I spent a long while trying to get `--allow-net` to work before realising this was necessary.\r\n\r\n`deno run --allow-net something.ts` vs `deno run something.ts --allow-net`\r\n\r\nIs there any reason not to support both forms?\r\n\r\nAlternately, a warning that the arguments were being ignored as invalid would have helped me understand."},{"labels":["documentation"],"text":"Both are currently empty:\r\nhttps://deno.land/manual/tools/dependency_inspector\r\nhttps://deno.land/manual/tools/documentation_generator\r\n"},{"labels":[null,"documentation"],"text":"The concept of _ops_ is mentioned in a few different locations in passing, but the manual should provide (at least) a high level overview of what they are, how they are consumed by the Deno \"front-end,\" and the process for adding new ops.\r\n\r\nExisting literature: https://github.com/denoland/deno/blob/master/docs/contributing.md#adding-ops-aka-bindings"},{"labels":["documentation",null],"text":"Using a dev build of https://github.com/denoland/vscode_deno\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/81877046-f63b2580-9538-11ea-8a2e-74000abd08a4.png)\r\n\r\nThis is because of these lines:\r\n\r\nhttps://github.com/denoland/deno/blob/d397b86c6cea1517342dfa92055d8ed00c564ee1/cli/js/lib.deno.ns.d.ts#L803-L805\r\n\r\nRecommendation:\r\n\r\n```\r\n    *      await Deno.mkdir(\"new_dir\"); \r\n    *      await Deno.mkdir(\"nested/directories\", { recursive: true }); \r\n    *      await Deno.mkdir(\"restricted_access_dir\", { mode: 0o700 }); \r\n```\r\n\r\nOr:\r\n\r\n```\r\n    * ```ts\r\n    * await Deno.mkdir(\"new_dir\"); \r\n    * await Deno.mkdir(\"nested/directories\", { recursive: true }); \r\n    * await Deno.mkdir(\"restricted_access_dir\", { mode: 0o700 }); \r\n    * ```\r\n```\r\n\r\nWe use the latter in the VS Code API:\r\n\r\n![image](https://user-images.githubusercontent.com/2193314/81877301-89745b00-9539-11ea-9e99-429cf9d6bd8d.png)\r\n"},{"labels":["documentation",null],"text":"\"resolves to the number of bytes written from p (0 <= n <= p.byteLength)\"\r\n\r\nbut also\r\n\r\n\"must reject with a non-null error if would resolve to n < p.byteLength\"\r\n\r\nSo which one is it: can it resolve with `n < p.byteLength` or not?\r\n\r\nAlso, would be nice to clarify if user can/implementor must support calling `write()` before previously returned promise has resolved."},{"labels":[null,"documentation"],"text":"I am currently trying to make use of Deno's native plugin API, and I've been having a hard time trying to gather the basic resources for plugin development. For the record, I've taken a look at a few implementations alongside the associated files with [`lib.rs`](https://github.com/denoland/deno/blob/master/core/lib.rs) found in `libdeno`.\r\n\r\nIs there any documentation for plugin development in Deno? If not, can we look into making one? If there does exist a solution, I'd be willing to migrate from the horrors of Node Addons. What I'm primary looking for is a:\r\n\r\n- Smooth development process and fluid production build release\r\n- Method to compile plugin with TypeScript as single executable\r\n\r\nCf. [`deno-plugin-prepare`](https://github.com/manyuanrong/deno-plugin-prepare), [`deno-webview`](https://github.com/eliassjogreen/deno_webview/)."},{"labels":["documentation"],"text":""},{"labels":["documentation",null],"text":"Deno strives to be browser compatible where possible; that means we use quite a few Web APIs. \r\n\r\nThere is not much docs for supported Web APIs at the moment and before 1.0 is released that situation must change. Some of APIs and not fully aligned to spec, while others are not fully implemented (#3557). All that knowledge should be written down and presented to end users to avoid multiple questions/bug reports about purposeful incompatibilities and/or missing implementations."}]