"""
This type stub file was generated by pyright.
"""

import logging
from collections import namedtuple
from celery import signals, states
from celery.utils.log import get_logger

"""Trace task execution.

This module defines how the task execution is traced:
errors are recorded, handlers are applied and so on.
"""
logger = get_logger(__name__)
LOG_SUCCESS = """\
Task %(name)s[%(id)s] succeeded in %(runtime)ss: %(return_value)s\
"""
LOG_FAILURE = """\
Task %(name)s[%(id)s] %(description)s: %(exc)s\
"""
LOG_INTERNAL_ERROR = """\
Task %(name)s[%(id)s] %(description)s: %(exc)s\
"""
LOG_IGNORED = """\
Task %(name)s[%(id)s] %(description)s\
"""
LOG_REJECTED = """\
Task %(name)s[%(id)s] %(exc)s\
"""
LOG_RETRY = """\
Task %(name)s[%(id)s] retry: %(exc)s\
"""
log_policy_t = namedtuple('log_policy_t', ('format', 'description', 'severity', 'traceback', 'mail'))
log_policy_reject = log_policy_t(LOG_REJECTED, 'rejected', logging.WARN, 1, 1)
log_policy_ignore = log_policy_t(LOG_IGNORED, 'ignored', logging.INFO, 0, 0)
log_policy_internal = log_policy_t(LOG_INTERNAL_ERROR, 'INTERNAL ERROR', logging.CRITICAL, 1, 1)
log_policy_expected = log_policy_t(LOG_FAILURE, 'raised expected', logging.INFO, 0, 0)
log_policy_unexpected = log_policy_t(LOG_FAILURE, 'raised unexpected', logging.ERROR, 1, 1)
send_prerun = signals.task_prerun.send
send_postrun = signals.task_postrun.send
send_success = signals.task_success.send
STARTED = states.STARTED
SUCCESS = states.SUCCESS
IGNORED = states.IGNORED
REJECTED = states.REJECTED
RETRY = states.RETRY
FAILURE = states.FAILURE
EXCEPTION_STATES = states.EXCEPTION_STATES
IGNORE_STATES = frozenset(IGNORED, RETRY, REJECTED)
_localized = []
_patched = {  }
trace_ok_t = namedtuple('trace_ok_t', ('retval', 'info', 'runtime', 'retstr'))
def info(fmt, context):
    """Log 'fmt % context' with severity 'INFO'.

    'context' is also passed in extra with key 'data' for custom handlers.
    """
    ...

def task_has_custom(task, attr):
    """Return true if the task overrides ``attr``."""
    ...

def get_log_policy(task, einfo, exc):
    ...

def get_task_name(request, default):
    """Use 'shadow' in request for the task name if applicable."""
    ...

class TraceInfo:
    """Information about task execution."""
    __slots__ = ...
    def __init__(self, state, retval=...) -> None:
        ...
    
    def handle_error_state(self, task, req, eager=..., call_errbacks=...):
        ...
    
    def handle_reject(self, task, req, **kwargs):
        ...
    
    def handle_ignore(self, task, req, **kwargs):
        ...
    
    def handle_retry(self, task, req, store_errors=..., **kwargs):
        """Handle retry exception."""
        ...
    
    def handle_failure(self, task, req, store_errors=..., call_errbacks=...):
        """Handle exception."""
        ...
    


def traceback_clear(exc=...):
    ...

def build_tracer(name, task, loader=..., hostname=..., store_errors=..., Info=..., eager=..., propagate=..., app=..., monotonic=..., trace_ok_t=..., IGNORE_STATES=...):
    """Return a function that traces task execution.

    Catches all exceptions and updates result backend with the
    state and result.

    If the call was successful, it saves the result to the task result
    backend, and sets the task status to `"SUCCESS"`.

    If the call raises :exc:`~@Retry`, it extracts
    the original exception, uses that as the result and sets the task state
    to `"RETRY"`.

    If the call results in an exception, it saves the exception as the task
    result, and sets the task state to `"FAILURE"`.

    Return a function that takes the following arguments:

        :param uuid: The id of the task.
        :param args: List of positional args to pass on to the function.
        :param kwargs: Keyword arguments mapping to pass on to the function.
        :keyword request: Request dict.

    """
    ...

def trace_task(task, uuid, args, kwargs, request=..., **opts):
    """Trace task execution."""
    ...

trace_task_ret = _trace_task_ret
def report_internal_error(task, exc):
    ...

def setup_worker_optimizations(app, hostname=...):
    """Setup worker related optimizations."""
    ...

def reset_worker_optimizations():
    """Reset previously configured optimizations."""
    ...

